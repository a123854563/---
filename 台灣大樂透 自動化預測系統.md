# ==============================================
# 台灣大樂透 自動化預測系統（多模型 + 特徵工程 + Walk-forward 回測）GUI版
# 模型：XGB / LGBM / CatBoost / Logistic / RF / CRF
# 介面：比照 539 GUI（執行/暫停/停止/查看結果 + 進度條 + 黑底輸出）
# ✅ 539 同款強化：
#   - 輸出區顯示「每個模型」tqdm 風格小進度條（會覆寫刷新，不會狂洗版）
#   - 完成後自動「另開新視窗」顯示摘要
# ✅ 修正：
#   - 移除 on_run() 多餘的 'F'（會 SyntaxError）
#   - K_interval / show_n 參數引用錯誤修正
# ✅ 修正(本次)：
#   - 補上 _make_text_readonly / _text_write（disabled Text 仍可寫入）
#   - 修正 _pump_queue：原本把 queue 資料拿出來就丟掉，導致輸出不會顯示
#   - open_result_window：補上顯示摘要文字、self.result_txt 指派
#   - Text 在 disabled 狀態會用 disabledforeground，因此補上 disabledforeground
# ✅ 本次整理（排版/變數命名更貼近 539）：
#   - run_pipeline 參數命名統一：BACKTEST_N / BACKTEST_MAIN_TOP_N / PRED_MAIN_TOP_N / K_INTERVAL / SHOW_N
#   - GUI 變數命名對齊：var_bt_main_top_n / var_pred_main_top_n
#   - K_INTERVAL_DEFAULT / SHOW_N_DEFAULT 取代 WALK_FORWARD_RETRAIN_INTERVAL / DISPLAY_LOGS_N
#   - 其他功能完全保留（大樂透多特別號流程保留）
# By Party87 + ChatGPT | 2026/01/04
# ==============================================

import os
import sys
import re
import csv
import time
import pickle
import random
import tempfile
import warnings
import contextlib
import multiprocessing
import threading
import queue
from io import StringIO
from math import comb
from datetime import datetime, date, timedelta, time as dtime
from collections import Counter, defaultdict

import joblib
import requests
import numpy as np
import pandas as pd
from tqdm import tqdm
from colorama import Fore, Style, init as colorama_init
from zoneinfo import ZoneInfo

from xgboost import XGBClassifier
from lightgbm import LGBMClassifier
from catboost import CatBoostClassifier
import sklearn_crfsuite

from sklearn.multioutput import MultiOutputClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.exceptions import ConvergenceWarning
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler
from sklearn.base import BaseEstimator, ClassifierMixin

import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext


# ==============================
# tqdm 風格文字小進度條（輸出區用）
# ==============================
TQDM_BAR_WIDTH = 28


def _sec_to_hhmmss(sec: float) -> str:
    sec = max(0.0, float(sec))
    m, s = divmod(int(sec + 0.5), 60)
    h, m = divmod(m, 60)
    if h > 0:
        return f"{h:02d}:{m:02d}:{s:02d}"
    return f"{m:02d}:{s:02d}"


def format_tqdm_line(label: str, i: int, total: int, elapsed_sec: float) -> str:
    total = max(1, int(total))
    i = max(0, min(int(i), total))
    frac = i / total
    pct = int(frac * 100)

    filled = int(round(frac * TQDM_BAR_WIDTH))
    filled = min(TQDM_BAR_WIDTH, max(0, filled))
    bar = "█" * filled + " " * (TQDM_BAR_WIDTH - filled)

    if i <= 0:
        eta = 0.0
        s_per_it_str = "?s/it"
    else:
        s_per_it = elapsed_sec / i
        eta = s_per_it * (total - i)
        s_per_it_str = f"{s_per_it:.2f}s/it"

    elapsed_str = _sec_to_hhmmss(elapsed_sec)
    eta_str = _sec_to_hhmmss(eta)

    return f"{label}: {pct:3d}%|{bar}| {i}/{total} [{elapsed_str}<{eta_str},  {s_per_it_str}]"


# ==============================
# sklearn 兼容 CatBoost wrapper
# ==============================
class SklearnCompatibleCatBoost(BaseEstimator, ClassifierMixin):
    """
    ✅ 解決 sklearn 新版要求 __sklearn_tags__ 但舊 CatBoostClassifier 沒有的問題
    - sklearn 看到的是 BaseEstimator/ClassifierMixin 的 wrapper（合規）
    - 內部再委派給 CatBoostClassifier
    """
    def __init__(self, cb_params=None):
        self.cb_params = cb_params if cb_params is not None else {}

    def fit(self, X, y):
        self.model_ = CatBoostClassifier(**self.cb_params)
        with suppress_all_output(True):
            self.model_.fit(X, y)
        self.classes_ = getattr(self.model_, "classes_", None)
        return self

    def predict(self, X):
        with suppress_all_output(True):
            return self.model_.predict(X)

    def predict_proba(self, X):
        with suppress_all_output(True):
            return self.model_.predict_proba(X)

    def get_params(self, deep=True):
        return {"cb_params": self.cb_params}

    def set_params(self, **params):
        if "cb_params" in params:
            self.cb_params = params["cb_params"]
        return self


# ==============================
# 輸出/雜訊控制
# ==============================
os.environ.setdefault("PYTHONWARNINGS", "ignore")

warnings.simplefilter("ignore")
warnings.filterwarnings("ignore", category=ConvergenceWarning)
warnings.filterwarnings("ignore", message=".*lbfgs failed to converge.*", module=r"sklearn\.linear_model\._logistic")
warnings.filterwarnings("ignore", category=UserWarning)
warnings.filterwarnings("ignore", category=FutureWarning)
warnings.filterwarnings("ignore", category=RuntimeWarning)


@contextlib.contextmanager
def suppress_all_output(enable=True):
    """enable=True 時：stdout/stderr/warnings 全部消音（訓練/預測用）"""
    if not enable:
        yield
        return

    old_showwarning = warnings.showwarning
    warnings.showwarning = lambda *args, **kwargs: None

    with open(os.devnull, "w") as devnull:
        with contextlib.redirect_stdout(devnull), contextlib.redirect_stderr(devnull):
            try:
                yield
            finally:
                warnings.showwarning = old_showwarning


# ==============================================
# 多執行緒/CPU 設定（B方案：外層不平行，模型內層吃多核）
# ==============================================
CPU_LOGICAL = multiprocessing.cpu_count()
AUTO_THREADS = max(1, CPU_LOGICAL - 1)

os.environ["OMP_NUM_THREADS"] = str(AUTO_THREADS)
os.environ["MKL_NUM_THREADS"] = str(AUTO_THREADS)
os.environ["OPENBLAS_NUM_THREADS"] = str(AUTO_THREADS)
os.environ["NUMEXPR_NUM_THREADS"] = str(AUTO_THREADS)
os.environ["VECLIB_MAXIMUM_THREADS"] = str(AUTO_THREADS)
os.environ["JOBLIB_MULTIPROCESSING"] = "1"

N_JOBS = AUTO_THREADS


# ==============================
# 可調參數（保留功能；命名更貼近 539）
# ==============================
FAST_MODE = True
TRAIN_WINDOW = 800 if FAST_MODE else None
DOWNLOAD_RETRY = 3

# 錯題本
MISTAKE_ALPHA_BASE = 0.05

SAVE_PROBA_CSV = True

USE_DETERMINISTIC = True
GLOBAL_SEED = 42

# GUI 會用到（不做按鈕）
K_INTERVAL_DEFAULT = 20

# GUI 顯示最近 N 期（不做按鈕）
SHOW_N_DEFAULT = 30

# 特別號：永遠只 1 支（回測/預測一致）
SPECIAL_TOP_N = 1

# ==============================
# 版路拖牌（保留；目前提示集合初始化仍在）
# ==============================
DRAG_ENABLE = True
DRAG_MAX_ROWS = 500
DRAG_PREDICT_LAGS = list(range(1, 11))
MIN_CHAIN_RUN = 2
DRAG_WRITE_TXT = True


# ==============================
# ✅ 開獎時間推估（規則 + 官方公告加開）
# ==============================
TZ_TAIPEI = ZoneInfo("Asia/Taipei")
LOTTO_DRAW_TIME = dtime(20, 30)  # 一般 20:30


def _to_taipei_now():
    return datetime.now(tz=TZ_TAIPEI)


def _parse_dates_from_text(txt: str):
    """
    從公告文字抓日期（支援）
    - YYYY/MM/DD
    - YYYY-MM-DD
    - 民國YYY/MM/DD（如 114/02/13）=> 2025/02/13
    """
    out = set()

    for m in re.finditer(r"(?<!\d)(20\d{2})[\/\-\.](\d{1,2})[\/\-\.](\d{1,2})(?!\d)", txt):
        y, mo, d = int(m.group(1)), int(m.group(2)), int(m.group(3))
        try:
            out.add(date(y, mo, d))
        except Exception:
            pass

    for m in re.finditer(r"(?<!\d)(\d{2,3})[\/\-\.](\d{1,2})[\/\-\.](\d{1,2})(?!\d)", txt):
        y0, mo, d = int(m.group(1)), int(m.group(2)), int(m.group(3))
        if y0 >= 1000:
            continue
        if y0 < 70:
            continue
        y = 1911 + y0
        try:
            out.add(date(y, mo, d))
        except Exception:
            pass

    return out


def _fetch_url_text(url, timeout=15):
    try:
        r = requests.get(
            url,
            timeout=timeout,
            headers={
                "User-Agent": (
                    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
                    "AppleWebKit/537.36 (KHTML, like Gecko) Chrome Safari"
                )
            },
        )
        r.raise_for_status()
        return r.text
    except Exception:
        return ""


def fetch_extra_draw_dates_from_official_announcements(days_ahead=120):
    """
    嘗試從官方公告抓「大樂透」加開/增開/春節開獎日期
    來源：
    - 台彩公告事項頁面
    - 中信彩券管理部 lotto.ctbcbank.com
    """
    now = _to_taipei_now().date()
    end = now + timedelta(days=days_ahead)
    candidates = set()

    tl_anno_url = "https://www.taiwanlottery.com/news/announcement/"
    tl_txt = _fetch_url_text(tl_anno_url)
    if tl_txt:
        if ("大樂透" in tl_txt) and (("加開" in tl_txt) or ("增開" in tl_txt) or ("春節" in tl_txt) or ("開獎" in tl_txt)):
            for d in _parse_dates_from_text(tl_txt):
                if now <= d <= end:
                    candidates.add(d)

    ctbc_home = "https://lotto.ctbcbank.com/"
    ctbc_txt = _fetch_url_text(ctbc_home)
    if ctbc_txt:
        if ("大樂透" in ctbc_txt) and (("加開" in ctbc_txt) or ("增開" in ctbc_txt) or ("春節" in ctbc_txt) or ("開獎" in ctbc_txt)):
            for d in _parse_dates_from_text(ctbc_txt):
                if now <= d <= end:
                    candidates.add(d)

    return candidates


def build_regular_draw_datetimes(now_dt, days_ahead=120):
    out = []
    start_date = now_dt.date()
    for k in range(days_ahead + 1):
        d = start_date + timedelta(days=k)
        if d.weekday() in (1, 4):  # Tue=1, Fri=4
            out.append(datetime(d.year, d.month, d.day, LOTTO_DRAW_TIME.hour, LOTTO_DRAW_TIME.minute, tzinfo=TZ_TAIPEI))
    return out


def infer_next_draw_datetime_by_rule_and_announcements(days_ahead=120):
    now_dt = _to_taipei_now()
    candidates_dt = set(build_regular_draw_datetimes(now_dt, days_ahead=days_ahead))

    extra_dates = fetch_extra_draw_dates_from_official_announcements(days_ahead=days_ahead)
    for d in extra_dates:
        candidates_dt.add(datetime(d.year, d.month, d.day, LOTTO_DRAW_TIME.hour, LOTTO_DRAW_TIME.minute, tzinfo=TZ_TAIPEI))

    future = sorted([x for x in candidates_dt if x > now_dt])
    if future:
        return future[0]

    fb = now_dt + timedelta(days=2)
    return datetime(fb.year, fb.month, fb.day, LOTTO_DRAW_TIME.hour, LOTTO_DRAW_TIME.minute, tzinfo=TZ_TAIPEI)


# ==============================
# 群組映射（1~49）
# ==============================
BAGUA_MAP = {
    1: "乾", 16: "乾", 17: "乾", 32: "乾", 40: "乾", 41: "乾",
    8: "坤", 9: "坤", 24: "坤", 25: "坤", 33: "坤", 48: "坤", 49: "坤",  # 49 補上
    6: "坎", 11: "坎", 22: "坎", 27: "坎", 35: "坎", 46: "坎",
    3: "離", 14: "離", 19: "離", 30: "離", 38: "離", 43: "離",
    5: "震", 12: "震", 21: "震", 28: "震", 36: "震", 45: "震",
    4: "巽", 13: "巽", 20: "巽", 29: "巽", 37: "巽", 44: "巽",
    2: "艮", 15: "艮", 18: "艮", 31: "艮", 39: "艮", 42: "艮",
    7: "兌", 10: "兌", 23: "兌", 26: "兌", 34: "兌", 47: "兌",
}

SHENGXIAO_MAP = {
    11: "羊", 23: "羊", 35: "羊", 47: "羊",
    10: "猴", 22: "猴", 34: "猴", 46: "猴",
    9: "雞", 21: "雞", 33: "雞", 45: "雞",
    8: "狗", 20: "狗", 32: "狗", 44: "狗",
    7: "豬", 19: "豬", 31: "豬", 43: "豬",
    6: "鼠", 18: "鼠", 30: "鼠", 42: "鼠",
    5: "牛", 17: "牛", 29: "牛", 41: "牛",
    4: "虎", 16: "虎", 28: "虎", 40: "虎",
    3: "兔", 15: "兔", 27: "兔", 39: "兔",
    2: "龍", 14: "龍", 26: "龍", 38: "龍",
    1: "蛇", 13: "蛇", 25: "蛇", 37: "蛇", 49: "蛇",
    12: "馬", 24: "馬", 36: "馬", 48: "馬",
}

MEAN_GROUP_MAP = {}
for i in range(1, 50):
    if 1 <= i <= 5:
        MEAN_GROUP_MAP[i] = "A"
    elif 6 <= i <= 10:
        MEAN_GROUP_MAP[i] = "B"
    elif 11 <= i <= 15:
        MEAN_GROUP_MAP[i] = "C"
    elif 16 <= i <= 20:
        MEAN_GROUP_MAP[i] = "D"
    elif 21 <= i <= 25:
        MEAN_GROUP_MAP[i] = "E"
    elif 26 <= i <= 30:
        MEAN_GROUP_MAP[i] = "F"
    elif 31 <= i <= 35:
        MEAN_GROUP_MAP[i] = "G"
    elif 36 <= i <= 40:
        MEAN_GROUP_MAP[i] = "H"
    elif 41 <= i <= 45:
        MEAN_GROUP_MAP[i] = "I"
    else:
        MEAN_GROUP_MAP[i] = "J"

WUXING_MAP = {
    13: "金", 14: "金", 21: "金", 22: "金", 29: "金", 30: "金", 43: "金", 44: "金",
    1: "木", 2: "木", 9: "木", 10: "木", 17: "木", 18: "木", 31: "木", 32: "木",
    39: "木", 40: "木", 47: "木", 48: "木",
    3: "水", 4: "水", 11: "水", 12: "水", 25: "水", 26: "水", 33: "水", 34: "水",
    41: "水", 42: "水",
    7: "火", 8: "火", 15: "火", 16: "火", 23: "火", 24: "火", 37: "火", 38: "火",
    45: "火", 46: "火",
    5: "土", 6: "土", 19: "土", 20: "土", 27: "土", 28: "土", 35: "土", 36: "土",
    49: "土",
}

LIUCHONG_MAP = {
    1: "子午", 7: "子午", 13: "子午", 19: "子午", 25: "子午", 31: "子午", 37: "子午", 43: "子午", 49: "子午",
    2: "丑未", 8: "丑未", 14: "丑未", 20: "丑未", 26: "丑未", 32: "丑未", 38: "丑未", 44: "丑未",
    3: "寅申", 9: "寅申", 15: "寅申", 21: "寅申", 27: "寅申", 33: "寅申", 39: "寅申", 45: "寅申",
    4: "卯酉", 10: "卯酉", 16: "卯酉", 22: "卯酉", 28: "卯酉", 34: "卯酉", 40: "卯酉", 46: "卯酉",
    5: "辰戌", 11: "辰戌", 17: "辰戌", 23: "辰戌", 29: "辰戌", 35: "辰戌", 41: "辰戌", 47: "辰戌",
    6: "巳亥", 12: "巳亥", 18: "巳亥", 24: "巳亥", 30: "巳亥", 36: "巳亥", 42: "巳亥", 48: "巳亥",
}

QIZHENG_MAP = {
    1: "日", 8: "日", 15: "日", 22: "日", 29: "日", 36: "日", 43: "日",
    2: "月", 9: "月", 16: "月", 23: "月", 30: "月", 37: "月", 44: "月",
    3: "火", 10: "火", 17: "火", 24: "火", 31: "火", 38: "火", 45: "火",
    4: "水", 11: "水", 18: "水", 25: "水", 32: "水", 39: "水", 46: "水",
    5: "木", 12: "木", 19: "木", 26: "木", 33: "木", 40: "木", 47: "木",
    6: "金", 13: "金", 20: "金", 27: "金", 34: "金", 41: "金", 48: "金",
    7: "土", 14: "土", 21: "土", 28: "土", 35: "土", 42: "土", 49: "土",
}


# ==============================
# CatBoost 訓練目錄（TEMP）
# ==============================
def ensure_catboost_train_dir():
    base = tempfile.gettempdir()
    abs_path = os.path.join(base, "catboost_tmp_party87")
    os.makedirs(abs_path, exist_ok=True)
    return abs_path


CATBOOST_TRAIN_DIR = ensure_catboost_train_dir()
os.environ["CATBOOST_TRAIN_DIR"] = CATBOOST_TRAIN_DIR
os.environ["TMP"] = CATBOOST_TRAIN_DIR
os.environ["TEMP"] = CATBOOST_TRAIN_DIR
os.environ["TMPDIR"] = CATBOOST_TRAIN_DIR


# ==============================
# 固定 seed
# ==============================
def set_global_seed(seed=42):
    random.seed(seed)
    np.random.seed(seed)
    os.environ["PYTHONHASHSEED"] = str(seed)


if USE_DETERMINISTIC:
    set_global_seed(GLOBAL_SEED)


# ==============================
# 下載/快取大樂透資料
# ==============================
def load_lotto649(force_download=False):
    DATA_CACHE = "lotto649_latest.csv"
    DATA_URL = "https://biga.com.tw/HISTORYDATA/rk8e49.csv"

    if (not force_download) and os.path.exists(DATA_CACHE):
        df = None
        for enc in ("utf-8-sig", "utf-8", "cp950", "big5"):
            try:
                df = pd.read_csv(DATA_CACHE, encoding=enc)
                break
            except Exception:
                df = None
        if df is None:
            raise RuntimeError(f"快取檔 {DATA_CACHE} 讀取失敗")

        if "期數" in df.columns:
            df["期數"] = pd.to_numeric(df["期數"], errors="coerce")
            df = df.dropna(subset=["期數", "日期"]).copy()
            df["期數"] = df["期數"].astype(int)
            df["日期"] = pd.to_datetime(df["日期"], errors="coerce")
            df = df.dropna(subset=["日期"]).copy()
            df = df.sort_values(["期數", "日期"], ascending=True).reset_index(drop=True)
        return df

    last_err = None
    for _ in range(DOWNLOAD_RETRY):
        try:
            r = requests.get(DATA_URL, timeout=20)
            r.raise_for_status()

            raw = r.content.decode("utf-8", errors="replace")
            df_raw = pd.read_csv(StringIO(raw), header=None)

            rows = []
            for row in df_raw.values.tolist():
                row = [str(x).strip() for x in row]
                if len(row) < 17:
                    continue
                row = row[:17]
                if len(row) != 17:
                    continue

                row.pop(9)
                row[0], row[1] = row[1], row[0]
                row[2:9], row[9:] = row[9:], row[2:9]
                row.insert(9, " ")
                rows.append(row)

            rows = rows[::-1]

            out = pd.DataFrame(
                rows,
                columns=[
                    "期數", "日期",
                    "正序號碼1", "正序號碼2", "正序號碼3", "正序號碼4", "正序號碼5", "正序號碼6",
                    "正序特別號",
                    " ",
                    "落序號碼1", "落序號碼2", "落序號碼3", "落序號碼4", "落序號碼5", "落序號碼6",
                    "落序特別號",
                ],
            ).drop(columns=[" "])

            out["日期"] = pd.to_datetime(out["日期"], errors="coerce")
            out["期數"] = pd.to_numeric(out["期數"], errors="coerce")

            num_cols = (
                [f"正序號碼{i}" for i in range(1, 7)]
                + ["正序特別號"]
                + [f"落序號碼{i}" for i in range(1, 7)]
                + ["落序特別號"]
            )
            for c in num_cols:
                out[c] = pd.to_numeric(out[c], errors="coerce")

            out = out.dropna(subset=["日期", "期數"] + num_cols).reset_index(drop=True)
            out["期數"] = out["期數"].astype(int)
            out[num_cols] = out[num_cols].astype(int)
            out = out.sort_values(["期數", "日期"], ascending=True).reset_index(drop=True)

            out.to_csv(DATA_CACHE, index=False, encoding="utf-8-sig")
            return out

        except Exception as e:
            last_err = e
            time.sleep(1.0)

    raise RuntimeError(f"下載官方資料失敗：{last_err}")


def load_lotto(force_download=False):
    return load_lotto649(force_download=force_download)


# ==============================
# 對獎：以「期數」優先（避免日期推算誤差）
# ==============================
def try_save_latest_prediction_result(df, main_cols, sp_col):
    pred_file = "latest_predict.csv"
    result_file = "latest_predict_result.csv"
    if not os.path.exists(pred_file):
        return

    pred_df = pd.read_csv(pred_file, dtype=str)
    df2 = df.copy()
    df2["日期"] = pd.to_datetime(df2["日期"], errors="coerce")

    if os.path.exists(result_file):
        result_df = pd.read_csv(result_file, dtype=str)
        recorded_keys = set(result_df.apply(lambda r: f"{r.get('預測期數','')}_{r.get('模型','')}", axis=1))
    else:
        recorded_keys = set()

    new_records = []
    for _, row in pred_df.iterrows():
        model = str(row.get("模型", "")).strip()
        pred_issue = str(row.get("預測期數", "")).strip()
        pred_date = str(row.get("預測日期", "")).strip()
        pred_main_str = str(row.get("預測主號", "")).strip()
        pred_sp_str = str(row.get("預測特別號", "")).strip()

        key = f"{pred_issue}_{model}"
        if key in recorded_keys:
            continue
        if not pred_main_str:
            continue

        pred_main = [int(x) for x in pred_main_str.split(",") if x.strip().isdigit()]
        pred_main = sorted(set(pred_main))

        pred_sp = None
        if pred_sp_str and pred_sp_str.strip().isdigit():
            pred_sp = int(pred_sp_str.strip())

        real_row = None
        if pred_issue.isdigit():
            real_row = df2[df2["期數"] == int(pred_issue)]
        if (real_row is None) or real_row.empty:
            if pred_date:
                pd0 = pred_date[:10]
                real_row = df2[df2["日期"].dt.strftime("%Y-%m-%d") == pd0]

        if real_row is None or real_row.empty:
            continue

        real_main = sorted(int(real_row.iloc[0][c]) for c in main_cols)
        real_sp = int(real_row.iloc[0][sp_col])
        real_date = real_row.iloc[0]["日期"].strftime("%Y-%m-%d")
        real_issue = int(real_row.iloc[0]["期數"])

        hit_main = len(set(pred_main) & set(real_main))
        hit_sp = int((pred_sp is not None) and (pred_sp == real_sp))

        new_records.append(
            {
                "預測日期": pred_date if pred_date else "",
                "預測期數": str(pred_issue) if pred_issue else "",
                "實際開獎日期": real_date,
                "實際開獎期數": str(real_issue),
                "模型": model,
                "預測主號": ",".join(f"{n:02d}" for n in sorted(pred_main)),
                "預測特別號": (f"{pred_sp:02d}" if isinstance(pred_sp, int) else ""),
                "開獎主號": ",".join(f"{n:02d}" for n in real_main),
                "開獎特別號": f"{real_sp:02d}",
                "主號命中數": str(hit_main),
                "特別號命中": str(hit_sp),
                "主號命中號碼": ",".join(f"{n:02d}" for n in sorted(set(pred_main) & set(real_main))),
            }
        )

    if new_records:
        df_new = pd.DataFrame(new_records)
        if os.path.exists(result_file):
            old = pd.read_csv(result_file, dtype=str)
            result_df = pd.concat([old, df_new], ignore_index=True)
        else:
            result_df = df_new

        result_df.to_csv(result_file, index=False, encoding="utf-8-sig")
        print(f"\n自動完成對獎結果存檔：{result_file}（本次新增 {len(df_new)} 筆）")


def try_save_latest_prediction_result_lotto(df):
    main_cols = [f"正序號碼{i}" for i in range(1, 7)]
    sp_col = "正序特別號"

    src = "latest_predict_lotto.csv"
    dst = "latest_predict.csv"
    if os.path.exists(src):
        try:
            pd.read_csv(src, dtype=str).to_csv(dst, index=False, encoding="utf-8-sig")
        except Exception:
            pass

    try_save_latest_prediction_result(df, main_cols, sp_col)

    if os.path.exists("latest_predict_result.csv"):
        try:
            pd.read_csv("latest_predict_result.csv", dtype=str).to_csv(
                "latest_predict_result_lotto.csv", index=False, encoding="utf-8-sig"
            )
        except Exception:
            pass


# ==============================
# 特徵工程（一次建滿；後續切片）
# ==============================
FEATURE_CACHE = {}


def feature_engineering(df, main_cols, feature_cols):
    if df is None or len(df) == 0:
        cache_key = ("EMPTY", -1, None, tuple(main_cols), tuple(feature_cols))
    else:
        last_date = None
        if "日期" in df.columns:
            try:
                last_date = pd.to_datetime(df["日期"].iloc[-1], errors="coerce")
                last_date = None if pd.isna(last_date) else last_date.strftime("%Y-%m-%d")
            except Exception:
                last_date = None

        last_issue = -1
        if "期數" in df.columns:
            try:
                last_issue = int(pd.to_numeric(df["期數"].iloc[-1], errors="coerce"))
            except Exception:
                last_issue = -1

        cache_key = (int(len(df)), int(last_issue), str(last_date), tuple(main_cols), tuple(feature_cols))

    if cache_key in FEATURE_CACHE:
        return FEATURE_CACHE[cache_key].copy()

    X = df[feature_cols].copy()

    if "日期" in df.columns:
        X["weekday"] = df["日期"].dt.weekday.astype(np.int8)
        X["month"] = df["日期"].dt.month.astype(np.int8)
        X["is_weekend"] = (X["weekday"] >= 5).astype(np.int8)

    X["max_num"] = df[main_cols].max(axis=1)
    X["min_num"] = df[main_cols].min(axis=1)
    X["sum_num"] = df[main_cols].sum(axis=1)
    X["mean_num"] = df[main_cols].mean(axis=1)
    X["std_num"] = df[main_cols].std(axis=1)
    X["range_num"] = X["max_num"] - X["min_num"]

    X["odd_count"] = df[main_cols].apply(lambda r: sum(int(n) % 2 for n in r), axis=1)
    X["even_count"] = 6 - X["odd_count"]
    X["odd_even_ratio"] = X["odd_count"] / (X["even_count"] + 1e-6)

    # ✅ 大小：小=01~24、大=25~48、49 另算
    X["small_count"] = df[main_cols].apply(lambda r: sum(1 <= int(n) <= 24 for n in r), axis=1).astype(np.int8)
    X["big_count"] = df[main_cols].apply(lambda r: sum(25 <= int(n) <= 48 for n in r), axis=1).astype(np.int8)
    X["draw49_count"] = df[main_cols].apply(lambda r: sum(int(n) == 49 for n in r), axis=1).astype(np.int8)
    X["big_small_score"] = (X["big_count"] - X["small_count"]).astype(np.int8)

    def count_serials(arr):
        s = sorted(int(x) for x in arr)
        return sum((s[i + 1] - s[i]) == 1 for i in range(len(s) - 1))

    X["serial_count"] = df[main_cols].apply(count_serials, axis=1)

    def repeat_count(cur, prev):
        return len(set(cur) & set(prev))

    X["repeat_prev"] = [0] + [repeat_count(df.loc[i, main_cols], df.loc[i - 1, main_cols]) for i in range(1, len(df))]

    for i in range(1, 7):
        col = f"正序號碼{i}"
        X[f"num{i}_尾數"] = (df[col] % 10).astype(np.int8)
        X[f"num{i}_合數"] = ((df[col] // 10 + df[col] % 10) % 10).astype(np.int8)

    # hot
    hot_frames = []
    for n in range(1, 50):
        num_mask = (df[main_cols] == n).sum(axis=1).astype(np.int16)
        col_all = pd.DataFrame({f"hot_{n:02d}_all": num_mask.cumsum().astype(np.int32)})
        col_windows = pd.DataFrame({f"hot_{n:02d}_{w}": num_mask.rolling(w, min_periods=1).sum().astype(np.float32) for w in [5, 10, 20, 30]})
        hot_frames.append(pd.concat([col_all, col_windows], axis=1))
    X = pd.concat([X.reset_index(drop=True), pd.concat(hot_frames, axis=1).reset_index(drop=True)], axis=1)

    # miss
    miss_features = pd.DataFrame(index=df.index)
    last_pos = {n: -1 for n in range(1, 50)}
    miss_counts = {n: [] for n in range(1, 50)}

    for i in range(len(df)):
        cur_set = set(int(x) for x in df.loc[i, main_cols])
        for n in range(1, 50):
            if n in cur_set:
                miss_counts[n].append(0)
                last_pos[n] = i
            else:
                miss_counts[n].append(i - last_pos[n] if last_pos[n] != -1 else i + 1)

    for n in range(1, 50):
        miss_features[f"miss_{n:02d}"] = pd.Series(miss_counts[n], dtype=np.int16)
    X = pd.concat([X.reset_index(drop=True), miss_features.reset_index(drop=True)], axis=1)

    # pair 共現
    pair_mean_list = []
    pair_max_list = []
    pair_counts = defaultdict(int)

    for i in range(len(df)):
        row_nums = sorted(int(df.loc[i, c]) for c in main_cols)
        pair_scores = []
        for a in range(5):
            for b in range(a + 1, 6):
                p = (row_nums[a], row_nums[b])
                pair_scores.append(pair_counts[p])

        pair_mean_list.append(float(np.mean(pair_scores)) if pair_scores else 0.0)
        pair_max_list.append(float(np.max(pair_scores)) if pair_scores else 0.0)

        for a in range(5):
            for b in range(a + 1, 6):
                pair_counts[(row_nums[a], row_nums[b])] += 1

    X["pair_cofreq_mean"] = pd.Series(pair_mean_list, index=df.index).astype(np.float32)
    X["pair_cofreq_max"] = pd.Series(pair_max_list, index=df.index).astype(np.float32)

    # 群組特徵
    def apply_group_feats(df_, main_cols_, name, mapping, X_):
        dummy_frames = []
        for i in range(1, 7):
            cat_col = df_[f"正序號碼{i}"].map(mapping).astype("category")
            dummies = pd.get_dummies(cat_col, prefix=f"{name}_num{i}")
            dummy_frames.append(dummies)

        if dummy_frames:
            X_ = pd.concat([X_.reset_index(drop=True), pd.concat(dummy_frames, axis=1).reset_index(drop=True)], axis=1)

        all_groups = sorted(set(mapping.values()))
        for k in all_groups:
            X_[f"{name}_{k}_count"] = df_[main_cols_].apply(lambda row: sum(mapping.get(int(n), "") == k for n in row), axis=1)
        return X_

    X = apply_group_feats(df, main_cols, "bagua", BAGUA_MAP, X)
    X = apply_group_feats(df, main_cols, "shengxiao", SHENGXIAO_MAP, X)
    X = apply_group_feats(df, main_cols, "mean_group", MEAN_GROUP_MAP, X)
    X = apply_group_feats(df, main_cols, "wuxing", WUXING_MAP, X)
    X = apply_group_feats(df, main_cols, "liuchong", LIUCHONG_MAP, X)
    X = apply_group_feats(df, main_cols, "qizheng", QIZHENG_MAP, X)

    for col in X.select_dtypes(include=["float64"]).columns:
        X[col] = X[col].astype(np.float32)
    for col in X.select_dtypes(include=["int64"]).columns:
        X[col] = X[col].astype(np.int32)

    FEATURE_CACHE[cache_key] = X.copy()
    return X


def build_full_features_once(df):
    main_cols = [f"正序號碼{i}" for i in range(1, 7)]
    sp_col = "正序特別號"
    feature_cols = main_cols + [sp_col] + [f"落序號碼{i}" for i in range(1, 7)] + ["落序特別號"]
    X_full = feature_engineering(df, main_cols, feature_cols)
    base_columns = list(X_full.columns)
    return X_full, base_columns, main_cols, sp_col, feature_cols


def build_full_features_once_lotto(df):
    X_full, base_columns, main_cols, sp_col, _ = build_full_features_once(df)
    return X_full, base_columns, main_cols, sp_col


def fix_columns(df_, columns):
    return df_.reindex(columns=columns, fill_value=0)


# ==============================
# 彩金盈虧（不含特別號）
# ==============================
def calc_prize(hits_list, top_n):
    ODDS = {"2星": 76.4, "3星": 893.0, "4星": 13500.0}
    total = {k: {"win": 0, "bets": 0, "cost": 0.0, "prize": 0.0, "profit": 0.0} for k in ODDS}

    for hit in hits_list:
        total["2星"]["bets"] += comb(top_n, 2) if top_n >= 2 else 0
        total["3星"]["bets"] += comb(top_n, 3) if top_n >= 3 else 0
        total["4星"]["bets"] += comb(top_n, 4) if top_n >= 4 else 0

        total["2星"]["win"] += comb(hit, 2) if hit >= 2 else 0
        total["3星"]["win"] += comb(hit, 3) if hit >= 3 else 0
        total["4星"]["win"] += comb(hit, 4) if hit >= 4 else 0

    for k in ODDS:
        total[k]["cost"] = float(total[k]["bets"]) * 1.0
        total[k]["prize"] = float(total[k]["win"]) * 1.0 * float(ODDS[k])
        total[k]["profit"] = total[k]["prize"] - total[k]["cost"]

    return total


def calc_prize_lotto(hits_list, top_n):
    return calc_prize(hits_list, top_n)


# ==============================
# 錯題本（只讀真實對獎）
# ==============================
def load_penalty_from_real_results_lotto(result_file="latest_predict_result_lotto.csv", max_ball=49):
    penalty = np.zeros(max_ball, dtype=np.float32)
    if not os.path.exists(result_file):
        return penalty

    try:
        df = pd.read_csv(result_file, dtype=str, encoding="utf-8-sig")
    except Exception:
        return penalty

    for _, r in df.iterrows():
        pred = str(r.get("預測主號", "")).strip()
        ans = str(r.get("開獎主號", "")).strip()
        hit_s = str(r.get("主號命中數", "")).strip()
        if not pred or not ans:
            continue

        try:
            pred_nums = [int(x) for x in pred.split(",") if x.strip().isdigit()]
            ans_nums = [int(x) for x in ans.split(",") if x.strip().isdigit()]
            hit = int(hit_s) if hit_s.isdigit() else len(set(pred_nums) & set(ans_nums))
        except Exception:
            continue

        if hit >= 2:
            continue

        w = 3.0 if hit == 0 else 2.0
        miss_nums = sorted(set(pred_nums) - set(ans_nums))
        for m in miss_nums:
            if 1 <= m <= max_ball:
                penalty[m - 1] += w

    return penalty


def get_auto_mistake_alpha(result_file="latest_predict_result_lotto.csv"):
    base = float(MISTAKE_ALPHA_BASE)
    if (not result_file) or (not os.path.exists(result_file)):
        return base

    try:
        df = pd.read_csv(result_file, dtype=str, encoding="utf-8-sig")
        n = len(df)
    except Exception:
        return base

    alpha = base * (1.0 + min(6.0, (n / 50.0)))
    return float(min(0.50, alpha))


# ==============================
# 多模型：主號(49多標籤) + 特別號(49多類別)
# ==============================
def _seed(seed_offset=0):
    if USE_DETERMINISTIC:
        return int((GLOBAL_SEED + seed_offset) % (2**32 - 1))
    raw = int(time.time_ns()) + random.randint(0, 1_000_000)
    return int(raw % (2**32 - 1))


def make_base_estimator(model_name, seed_offset=0):
    n_cpu = max(1, int(N_JOBS))

    if model_name == "XGBoost":
        params_fast = dict(n_estimators=60, max_depth=3, learning_rate=0.12, subsample=0.8, colsample_bytree=0.8)
        params_full = dict(n_estimators=160, max_depth=4, learning_rate=0.10, subsample=0.9, colsample_bytree=0.9)
        params = params_fast if FAST_MODE else params_full

        return XGBClassifier(
            tree_method="hist",
            use_label_encoder=False,
            eval_metric="logloss",
            n_jobs=n_cpu,
            verbosity=0,
            random_state=_seed(seed_offset),
            **params,
        )

    if model_name == "LightGBM":
        params_fast = dict(n_estimators=120, num_leaves=31, learning_rate=0.08, subsample=0.9, colsample_bytree=0.9)
        params_full = dict(n_estimators=300, num_leaves=63, learning_rate=0.06, subsample=0.9, colsample_bytree=0.9)
        params = params_fast if FAST_MODE else params_full
        return LGBMClassifier(**params, n_jobs=n_cpu, random_state=_seed(seed_offset), verbose=-1)

    if model_name == "CatBoost":
        params_fast = dict(iterations=120, depth=4, learning_rate=0.12, bootstrap_type="Bernoulli", subsample=0.8, rsm=0.8)
        params_full = dict(iterations=500, depth=5, learning_rate=0.10)
        params = params_fast if FAST_MODE else params_full

        cb_params = dict(
            task_type="CPU",
            thread_count=n_cpu,
            verbose=0,
            allow_writing_files=False,
            train_dir=CATBOOST_TRAIN_DIR,
            random_seed=_seed(seed_offset),
            **params,
        )
        return SklearnCompatibleCatBoost(cb_params=cb_params)

    if model_name == "Logistic":
        max_iter = 3000 if FAST_MODE else 8000
        tol = 1e-3 if FAST_MODE else 5e-4
        base_lr = LogisticRegression(
            C=1.0,
            max_iter=max_iter,
            tol=tol,
            solver="saga",
            penalty="l2",
            n_jobs=n_cpu,
        )
        return Pipeline([("scaler", StandardScaler()), ("clf", base_lr)])

    if model_name == "RandomForest":
        params_fast = dict(n_estimators=80, max_depth=7)
        params_full = dict(n_estimators=200, max_depth=None)
        params = params_fast if FAST_MODE else params_full
        return RandomForestClassifier(**params, n_jobs=n_cpu, random_state=_seed(seed_offset))

    raise ValueError("Unknown model")


def make_multi_model_for_main(model_name, seed_offset=0):
    base = make_base_estimator(model_name, seed_offset=seed_offset)
    return MultiOutputClassifier(base, n_jobs=1)


def proba_from_multioutput(mo_clf, X_pred_row):
    probas = []
    for est in mo_clf.estimators_:
        p = est.predict_proba(X_pred_row)
        if p.shape[1] == 2:
            probas.append(float(p[0, 1]))
        else:
            probas.append(float(p[0, 0]))
    return np.array(probas, dtype=np.float32)


def fit_special_classifier(model_name, X_train, y_train, seed_offset=0):
    base = make_base_estimator(model_name, seed_offset=seed_offset)

    y_fit = y_train.copy()
    if model_name == "XGBoost":
        y_fit = (y_fit.astype(int) - 1).astype(int)

    with joblib.parallel_backend("threading"):
        with suppress_all_output(True):
            base.fit(X_train, y_fit)
    return base


def predict_special_proba(model_name, clf, X_pred_row, max_ball=49):
    with suppress_all_output(True):
        if hasattr(clf, "predict_proba"):
            proba = clf.predict_proba(X_pred_row)
            if proba.ndim == 2 and proba.shape[0] == 1:
                out = np.zeros(max_ball, dtype=np.float32)
                classes = getattr(clf, "classes_", None)
                if classes is None:
                    m = min(max_ball, proba.shape[1])
                    out[:m] = proba[0, :m].astype(np.float32)
                    return out

                for j, c in enumerate(classes):
                    cc = int(c)
                    if model_name == "XGBoost":
                        cc = cc + 1
                    if 1 <= cc <= max_ball:
                        out[cc - 1] = float(proba[0, j])
                return out
        return np.zeros(max_ball, dtype=np.float32)


# ==============================
# CRF：主號序列（1~49）
# ==============================
def crf_token_features_from_row(row, n):
    fmt = f"{n:02d}"
    feat = {
        "n": n,
        "n_mod10": n % 10,
        "n_bin": n // 10,
        "hot_all": float(row.get(f"hot_{fmt}_all", 0.0)),
        "hot_5": float(row.get(f"hot_{fmt}_5", 0.0)),
        "hot_10": float(row.get(f"hot_{fmt}_10", 0.0)),
        "hot_20": float(row.get(f"hot_{fmt}_20", 0.0)),
        "hot_30": float(row.get(f"hot_{fmt}_30", 0.0)),
        "miss": float(row.get(f"miss_{fmt}", 0.0)),
        "odd_cnt": int(row.get("odd_count", 0)),
        "even_cnt": int(row.get("even_count", 0)),
        "serial_cnt": int(row.get("serial_count", 0)),
        "repeat_prev": int(row.get("repeat_prev", 0)),
        "big_small": float(row.get("big_small_score", 0.0)),
    }
    return feat


def build_crf_seq_features(X_bt, idx, max_ball=49):
    row = X_bt.iloc[idx]
    return [crf_token_features_from_row(row, n) for n in range(1, max_ball + 1)]


def build_crf_labels(y_main, idx, max_ball=49):
    row = y_main.iloc[idx]
    return ["1" if int(row[f"y_{n:02d}"]) == 1 else "0" for n in range(1, max_ball + 1)]


def fit_crf(X_bt, y_main, start_idx, end_idx, max_ball=49):
    X_seqs = [build_crf_seq_features(X_bt, t, max_ball=max_ball) for t in range(start_idx, end_idx)]
    y_seqs = [build_crf_labels(y_main, t, max_ball=max_ball) for t in range(start_idx, end_idx)]
    max_iter = 60 if FAST_MODE else 150

    crf = sklearn_crfsuite.CRF(
        algorithm="lbfgs",
        c1=0.1,
        c2=0.1,
        max_iterations=max_iter,
        all_possible_transitions=True,
    )

    with suppress_all_output(True):
        crf.fit(X_seqs, y_seqs)

    return crf


def crf_predict_proba(crf, X_bt, idx, max_ball=49):
    feats = build_crf_seq_features(X_bt, idx, max_ball=max_ball)
    marginals = crf.predict_marginals_single(feats)
    probs = [float(m.get("1", 0.0)) for m in marginals]
    return np.array(probs, dtype=np.float32)


# ==============================
# 工具：顯示格式
# ==============================
def format_nums(nums_list):
    return "[" + ", ".join(f"{int(n):02d}" for n in sorted(map(int, nums_list))) + "]"


def format_nums_with_star(nums_list, star_set):
    parts = []
    for n in sorted(map(int, nums_list)):
        mark = "★" if int(n) in star_set else ""
        parts.append(f"{int(n):02d}{mark}")
    return "[" + ", ".join(parts) + "]"


def pick_topn_stable(scores, top_n):
    s = np.asarray(scores, dtype=np.float64)
    n = s.shape[0]
    order = np.lexsort((np.arange(n, dtype=np.int32), -s))
    pick_idx = order[:top_n]
    return sorted([int(i + 1) for i in pick_idx])


# ==============================
# ✅ 539 同款：隨機建議票
# ==============================
def weighted_sample_without_replacement(items, weights, k, rng):
    items = np.array(items, dtype=int)
    w = np.array(weights, dtype=float)
    w = np.maximum(w, 0.0)
    if w.sum() <= 0:
        w = np.ones_like(w, dtype=float)
    w = w / w.sum()
    pick = rng.choice(items, size=k, replace=False, p=w)
    return sorted(map(int, pick))


def suggest_tickets_from_scores(combined_main_scores, sp_scores_sum, num_tickets=10, main_pool_top=22, seed=42):
    rng = np.random.default_rng(seed)

    scores = combined_main_scores.astype(np.float64)
    idx_sorted = np.argsort(scores)[::-1]
    pool_idx = idx_sorted[:max(main_pool_top, 6)]
    pool_nums = (pool_idx + 1).astype(int).tolist()
    pool_w = scores[pool_idx].tolist()

    sp_scores = sp_scores_sum.astype(np.float64)
    sp_scores = np.maximum(sp_scores, 0.0)
    if sp_scores.sum() <= 0:
        sp_scores = np.ones(49, dtype=np.float64)
    sp_probs = sp_scores / sp_scores.sum()

    sp_nums = np.arange(1, 50, dtype=int)

    tickets = []
    for _ in range(int(num_tickets)):
        main_pick = weighted_sample_without_replacement(pool_nums, pool_w, k=6, rng=rng)
        sp_pick = int(rng.choice(sp_nums, p=sp_probs))
        tickets.append((main_pick, sp_pick))
    return tickets


# ==============================
# Walk-forward：訓練/預測封裝
# ==============================
def fit_model_main_for_i(model_name, X_bt, y_main, base_columns, start_idx, i, seed_offset=0):
    if model_name == "CRF":
        return fit_crf(X_bt, y_main, start_idx, i, max_ball=49)

    y_cols = [f"y_{k:02d}" for k in range(1, 50)]
    X_train = fix_columns(X_bt.iloc[start_idx:i], base_columns)
    y_train = y_main[y_cols].iloc[start_idx:i]

    mo = make_multi_model_for_main(model_name, seed_offset=seed_offset)
    with suppress_all_output(True):
        mo.fit(X_train, y_train)
    return mo


def predict_scores_main_for_i(model_name, model_obj, X_bt, base_columns, i):
    if model_name == "CRF":
        with suppress_all_output(True):
            return crf_predict_proba(model_obj, X_bt, i, max_ball=49)

    X_pred = fix_columns(X_bt.iloc[[i]], base_columns)
    with suppress_all_output(True):
        return proba_from_multioutput(model_obj, X_pred)


def fit_model_sp_for_i(model_name, X_bt, y_sp, base_columns, start_idx, i, seed_offset=0):
    X_train = fix_columns(X_bt.iloc[start_idx:i], base_columns)
    y_train = y_sp.iloc[start_idx:i].astype(int)

    mask = (y_train >= 1) & (y_train <= 49)
    X_train = X_train.loc[mask]
    y_train = y_train.loc[mask]
    if len(y_train) < 30:
        return None

    return fit_special_classifier(model_name, X_train, y_train, seed_offset=seed_offset)


def predict_scores_sp_for_i(model_name, clf_sp, X_bt, base_columns, i):
    X_pred = fix_columns(X_bt.iloc[[i]], base_columns)
    if clf_sp is None:
        return np.zeros(49, dtype=np.float32)
    return predict_special_proba(model_name, clf_sp, X_pred, max_ball=49)


# ==============================
# GUI 主流程（539風格命名）
# ==============================
def run_pipeline(
    BACKTEST_N: int,
    BACKTEST_MAIN_TOP_N: int,
    PRED_MAIN_TOP_N: int,
    K_INTERVAL: int,
    SHOW_N: int,
    q_print,              # function(str) -> append
    q_overwrite,          # function(model:str, line:str) -> overwrite progress line
    on_progress,          # (status_text, progress_0to1)
    stop_event,
    pause_event,
):
    colorama_init(autoreset=True)

    def gprint(s=""):
        q_print(s + "\n")

    def _check_pause_stop():
        if stop_event.is_set():
            raise KeyboardInterrupt("STOP_REQUESTED")
        while pause_event.is_set():
            time.sleep(0.15)
            if stop_event.is_set():
                raise KeyboardInterrupt("STOP_REQUESTED")

    BACKTEST_N = int(BACKTEST_N)
    BACKTEST_MAIN_TOP_N = int(BACKTEST_MAIN_TOP_N)
    PRED_MAIN_TOP_N = int(PRED_MAIN_TOP_N)
    K_INTERVAL = max(1, int(K_INTERVAL))
    SHOW_N = max(1, int(SHOW_N))

    model_names = ["XGBoost", "LightGBM", "CatBoost", "Logistic", "RandomForest", "CRF"]

    FIX_STEPS = 10
    BT_STEPS = len(model_names) * BACKTEST_N
    PRED_STEPS = len(model_names)
    TOTAL_STEPS = FIX_STEPS + BT_STEPS + PRED_STEPS
    done_steps = 0

    def set_status(s, add_steps=0):
        nonlocal done_steps
        if add_steps:
            done_steps = min(TOTAL_STEPS, done_steps + int(add_steps))
        p = float(done_steps) / float(TOTAL_STEPS)
        on_progress(s, p)

    gprint(f"本機邏輯核心數：{CPU_LOGICAL} | AUTO_THREADS：{AUTO_THREADS} | JOBLIB_MULTIPROCESSING={os.environ.get('JOBLIB_MULTIPROCESSING')}")
    gprint(f"回測期數：{BACKTEST_N} | 回測主號TOP_N：{BACKTEST_MAIN_TOP_N} | 預測主號TOP_N：{PRED_MAIN_TOP_N} | K(每幾期重訓)：{K_INTERVAL}")
    gprint("============================================================")

    set_status("狀態：下載/載入資料...", add_steps=1)
    gprint("下載/載入官方大樂透資料...")
    _check_pause_stop()
    df = load_lotto(force_download=True)
    set_status("狀態：下載/載入資料完成", add_steps=1)

    nums_main = [f"正序號碼{i}" for i in range(1, 7)]
    col_sp = "正序特別號"

    gprint(f"==== 全部期數：{len(df)} 筆 ====")
    gprint(f"最後一筆：期數 {int(df.iloc[-1]['期數'])} | 日期 {pd.to_datetime(df.iloc[-1]['日期']).strftime('%Y-%m-%d')}")
    set_status("狀態：資料檢查完成", add_steps=1)

    _check_pause_stop()
    set_status("狀態：對獎檢查...", add_steps=1)
    try:
        try_save_latest_prediction_result_lotto(df)
    except Exception as e:
        gprint(f"對獎程序例外（不影響主流程）：{e}")
    set_status("狀態：對獎檢查完成", add_steps=1)

    _check_pause_stop()
    set_status("狀態：特徵工程建置...", add_steps=1)
    X_full, base_columns, _, _ = build_full_features_once_lotto(df)
    X_bt = X_full.reset_index(drop=True)
    df_bt = df.reset_index(drop=True)
    set_status("狀態：特徵工程完成", add_steps=1)

    _check_pause_stop()
    future_main = df[nums_main].shift(-1)
    future_sp = df[col_sp].shift(-1)

    y_main = (
        pd.DataFrame({f"y_{i:02d}": future_main.apply(lambda x, i=i: int(i in x.values), axis=1).astype(np.int8) for i in range(1, 50)})
        .reset_index(drop=True)
    )
    y_sp = future_sp.fillna(0).astype(int).reset_index(drop=True)

    num_rows = X_bt.shape[0]
    feature_row_count = num_rows - 1

    if feature_row_count < BACKTEST_N or BACKTEST_N <= 0:
        raise RuntimeError(f"【錯誤】可回測期數 ({feature_row_count}) 必須大於回測期數 ({BACKTEST_N})！")

    backtest_indexes = list(range(feature_row_count - BACKTEST_N, feature_row_count))
    backtest_eval_start_date = df_bt.iloc[backtest_indexes[0] + 1]["日期"].date()
    backtest_eval_end_date = df_bt.iloc[backtest_indexes[-1] + 1]["日期"].date()

    latest_issue = int(df_bt.iloc[-1]["期數"])
    predict_next_issue = latest_issue + 1

    next_draw_dt = infer_next_draw_datetime_by_rule_and_announcements(days_ahead=160)
    now_dt = _to_taipei_now()

    gprint(f"==== 回測評估日期（實際被預測開獎日）: {backtest_eval_start_date} ~ {backtest_eval_end_date} ====")
    gprint(f"==== 現在時間(台北) : {now_dt.strftime('%Y-%m-%d %H:%M:%S %Z')} ====")
    gprint(f"==== 預測下一期（期數優先）：期數 {predict_next_issue} / 開獎時間(推估) {next_draw_dt.strftime('%Y-%m-%d %H:%M')} ====")
    gprint(f"==== Walk-forward 回測：每 {K_INTERVAL} 期重訓一次（K={K_INTERVAL}） ====")
    set_status("狀態：回測準備完成", add_steps=1)

    drag_hint_main = set()
    drag_hint_sp = set()
    set_status("狀態：拖牌提示初始化", add_steps=1)

    total_start = time.time()
    error_logs = []
    model_hits_main = {}
    model_hits_sp = {}
    model_logs = {}
    model_prizes = {}

    def run_backtest_walkforward(model_name, model_idx, model_total):
        hits_main, hits_sp, logs = [], [], []
        gprint(f"\n--- 開始模型 [{model_name}] Walk-forward 回測 ---")

        K = max(1, int(K_INTERVAL))
        model_main = None
        model_sp = None
        last_fit_i = None
        fit_count = 0

        wf_total = len(backtest_indexes)
        wf_t0 = time.time()

        q_overwrite(model_name, format_tqdm_line(f"回測WF [{model_name}]", 0, wf_total, 0.0))

        for j, i in enumerate(backtest_indexes, start=1):
            _check_pause_stop()

            start_idx = 0 if (TRAIN_WINDOW is None) else max(0, i - TRAIN_WINDOW)

            need_refit = (model_main is None) or (last_fit_i is None) or ((i - last_fit_i) >= K)
            if need_refit:
                try:
                    seed_offset = (fit_count * 1000) + (model_names.index(model_name) * 100)
                    model_main = fit_model_main_for_i(model_name, X_bt, y_main, base_columns, start_idx, i, seed_offset=seed_offset)
                    sp_model_name = model_name if model_name != "CRF" else "LightGBM"
                    model_sp = fit_model_sp_for_i(sp_model_name, X_bt, y_sp, base_columns, start_idx, i, seed_offset=seed_offset + 7)

                    last_fit_i = i
                    fit_count += 1
                except Exception as e:
                    error_logs.append(f"{model_name} | fit_i={i} | {str(e)}")
                    model_main = None
                    model_sp = None

            try:
                if model_main is None:
                    scores_main = np.zeros(49, dtype=np.float32)
                else:
                    scores_main = predict_scores_main_for_i(model_name, model_main, X_bt, base_columns, i)
            except Exception as e:
                error_logs.append(f"{model_name} | pred_main_i={i} | {str(e)}")
                scores_main = np.zeros(49, dtype=np.float32)

            pred_main = pick_topn_stable(scores_main, BACKTEST_MAIN_TOP_N)

            try:
                sp_model_name = model_name if model_name != "CRF" else "LightGBM"
                scores_sp = predict_scores_sp_for_i(sp_model_name, model_sp, X_bt, base_columns, i)
            except Exception as e:
                error_logs.append(f"{model_name} | pred_sp_i={i} | {str(e)}")
                scores_sp = np.zeros(49, dtype=np.float32)

            pred_sp = int(np.argmax(scores_sp) + 1) if scores_sp.sum() > 0 else int(df_bt.iloc[i][col_sp])

            real_idx = i + 1
            real_date = df_bt.iloc[real_idx]["日期"].date()
            real_main = [int(x) for x in df_bt.iloc[real_idx][nums_main].values]
            real_sp = int(df_bt.iloc[real_idx][col_sp])

            hit_main = len(set(pred_main) & set(real_main))
            hit_sp = 1 if pred_sp == real_sp else 0

            hits_main.append(hit_main)
            hits_sp.append(hit_sp)

            logs.append(
                f"{model_name:<12} | {real_date} | 主號命中:{hit_main:<1d} | 特別號命中:{hit_sp:<1d} | "
                f"預測主號:{format_nums(pred_main)} | 預測特別號:{format_nums([pred_sp])} | "
                f"開獎主號:{format_nums(real_main)} | 開獎特別號:{format_nums([real_sp])}"
            )

            elapsed = time.time() - wf_t0
            q_overwrite(model_name, format_tqdm_line(f"回測WF [{model_name}]", j, wf_total, elapsed))
            set_status(f"狀態：回測中 {model_name}({model_idx+1}/{model_total})", add_steps=1)

        prize_stat = calc_prize_lotto(hits_main, BACKTEST_MAIN_TOP_N)
        gprint(f"--- 完成模型 [{model_name}] Walk-forward 回測 ---")
        return model_name, hits_main, hits_sp, logs, prize_stat

    set_status("狀態：回測中...", add_steps=0)
    for idx, mn in enumerate(model_names):
        _check_pause_stop()
        k, hits_m, hits_s, logs, prize_stat = run_backtest_walkforward(mn, idx, len(model_names))
        model_hits_main[k] = hits_m
        model_hits_sp[k] = hits_s
        model_logs[k] = logs
        model_prizes[k] = prize_stat

    total_end = time.time()
    gprint(f"\n回測全部模型總耗時：{total_end - total_start:.2f} 秒")

    if error_logs:
        with open("error_log.txt", "a", encoding="utf-8-sig") as ef:
            for line in error_logs:
                ef.write(line + "\n")
        gprint("【已記錄異常於 error_log.txt】")

    nowtag = datetime.now().strftime("%Y%m%d_%H%M%S")

    backtest_log_file = f"backtest_all_models_WF_{BACKTEST_N}N_K{K_INTERVAL}_{nowtag}.txt"
    with open(backtest_log_file, "w", encoding="utf-8-sig") as f:
        f.write("Walk-forward 回測總表（大樂透：主6+特1）\n")
        f.write(f"日期範圍(被預測開獎日)：{backtest_eval_start_date} ~ {backtest_eval_end_date}\n")
        f.write(f"回測期數：{BACKTEST_N}\n")
        f.write(f"K(每幾期重訓)：{K_INTERVAL}\n")
        f.write(f"回測主號TOP_N：{BACKTEST_MAIN_TOP_N}\n")
        f.write("=" * 100 + "\n\n")
        for mn in model_names:
            f.write(f"[{mn}] 回測命中紀錄（完整）\n")
            for line in model_logs.get(mn, []):
                f.write(line + "\n")
            f.write("\n")

    gprint(f"\n✅ 已輸出「全部模型完整回測紀錄」到檔案：{backtest_log_file}")
    set_status("狀態：輸出回測紀錄", add_steps=1)

    history_fname = f"history_lotto_WF_{BACKTEST_N}N_K{K_INTERVAL}_bt{BACKTEST_MAIN_TOP_N}_pred{PRED_MAIN_TOP_N}_{nowtag}.pkl"
    history_data = {
        "datetime": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "mode": "walk_forward",
        "K": int(K_INTERVAL),
        "backtest_eval_start_date": str(backtest_eval_start_date),
        "backtest_eval_end_date": str(backtest_eval_end_date),
        "backtest_N": int(BACKTEST_N),
        "BACKTEST_MAIN_TOP_N": int(BACKTEST_MAIN_TOP_N),
        "PRED_MAIN_TOP_N": int(PRED_MAIN_TOP_N),
        "TRAIN_WINDOW": int(TRAIN_WINDOW) if TRAIN_WINDOW is not None else None,
        "FAST_MODE": bool(FAST_MODE),
        "USE_DETERMINISTIC": bool(USE_DETERMINISTIC),
        "GLOBAL_SEED": int(GLOBAL_SEED),
        "model_hits_main": model_hits_main,
        "model_hits_sp": model_hits_sp,
        "model_prizes": model_prizes,
    }
    with open(history_fname, "wb") as f:
        pickle.dump(history_data, f)
    gprint(f"已輸出回測統計檔：{history_fname}")
    set_status("狀態：輸出統計檔", add_steps=1)

    gprint(f"\n==== 各模型回測命中紀錄（僅顯示最近 {SHOW_N} 期；完整見 {backtest_log_file}） ====")

    total_profit_map = {}
    for k in model_names:
        gprint(f"\n{k} 回測命中紀錄（最近 {SHOW_N} 期）：")
        for log in model_logs.get(k, [])[-SHOW_N:]:
            gprint(log)

        gprint(f"{k}【回測獎金統計】(回測 主號TOP_{BACKTEST_MAIN_TOP_N} / 不含特別號)")

        total_profit = 0.0
        for star in ["2星", "3星", "4星"]:
            pz = model_prizes[k][star]
            total_profit += float(pz.get("profit", 0.0))
            gprint(
                f"  {star}  總中獎組數：{pz['win']}，總投注：{pz['bets']}，花費：{pz['cost']} 元，"
                f"彩金：{int(pz['prize'])} 元，盈虧：{int(pz['profit'])} 元"
            )
        total_profit_map[k] = int(total_profit)

    ranked = sorted(total_profit_map.items(), key=lambda x: x[1], reverse=True)
    gprint(f"\n==== 各模型總計盈虧排名（Walk-forward / 回測 TOP_{BACKTEST_MAIN_TOP_N}） ====")
    for i, (mn, prof) in enumerate(ranked, start=1):
        gprint(f"{i}. {mn:<12} ➤【總計盈虧】：{prof} 元")

    gprint(f"\n==== 各模型平均命中總結（Walk-forward / 主號TOP_{BACKTEST_MAIN_TOP_N}） ====")
    for k in model_names:
        avg_main = float(np.mean(model_hits_main[k])) if model_hits_main[k] else 0.0
        std_main = float(np.std(model_hits_main[k])) if model_hits_main[k] else 0.0
        avg_sp = float(np.mean(model_hits_sp[k])) if model_hits_sp[k] else 0.0
        gprint(f"{k:<12} | 主號平均命中：{avg_main:.2f}（σ={std_main:.2f}） | 特別號命中率：{avg_sp*100:.1f}%")

    set_status("狀態：預測中...", add_steps=1)

    all_model_pred_main_scores = {}
    all_model_pred_sp_scores = {}
    all_model_predictions_main = {}
    all_model_predictions_sp = {}

    def predict_one_model(model_name):
        i = len(X_bt) - 1
        start_idx = 0 if (TRAIN_WINDOW is None) else max(0, i - TRAIN_WINDOW)
        seed_offset = 999_000 + (model_names.index(model_name) * 100)

        try:
            model_main = fit_model_main_for_i(model_name, X_bt, y_main, base_columns, start_idx, i, seed_offset=seed_offset)
            scores_main = predict_scores_main_for_i(model_name, model_main, X_bt, base_columns, i)
        except Exception as e:
            gprint(f"{model_name} 主號預測例外: {e}")
            scores_main = np.zeros(49, dtype=np.float32)

        pred_main = pick_topn_stable(scores_main, PRED_MAIN_TOP_N)

        sp_model_name = model_name if model_name != "CRF" else "LightGBM"
        try:
            model_sp = fit_model_sp_for_i(sp_model_name, X_bt, y_sp, base_columns, start_idx, i, seed_offset=seed_offset + 7)
            scores_sp = predict_scores_sp_for_i(sp_model_name, model_sp, X_bt, base_columns, i)
        except Exception as e:
            gprint(f"{model_name} 特別號預測例外: {e}")
            scores_sp = np.zeros(49, dtype=np.float32)

        pred_sp = int(np.argmax(scores_sp) + 1) if scores_sp.sum() > 0 else int(df_bt.iloc[-1][col_sp])
        return pred_main, pred_sp, scores_main, scores_sp

    for idx, mn in enumerate(model_names):
        _check_pause_stop()

        gprint(f"\n>>> [PRED] 開始訓練+預測：{mn} ...")
        set_status(f"狀態：預測中 {mn}({idx+1}/{len(model_names)})", add_steps=0)

        t0_fit = time.time()
        pred_main, pred_sp, scores_main, scores_sp = predict_one_model(mn)
        t1 = time.time()

        gprint(f">>> [PRED] 完成：{mn}，總耗時 {t1 - t0_fit:.2f} 秒")

        all_model_predictions_main[mn] = pred_main
        all_model_predictions_sp[mn] = pred_sp
        all_model_pred_main_scores[mn] = scores_main
        all_model_pred_sp_scores[mn] = scores_sp

        gprint(f"{mn:<12} | 預測期數 {predict_next_issue} / 開獎時間(推估) {next_draw_dt.strftime('%Y-%m-%d %H:%M')}")
        gprint(f"  預測主號（大小序）：{format_nums_with_star(pred_main, drag_hint_main)}")
        gprint(f"  預測特別號（1支）：{format_nums_with_star([pred_sp], drag_hint_sp)}")
        gprint("-" * 80)

        if SAVE_PROBA_CSV:
            pd.DataFrame({"number": [f"{i:02d}" for i in range(1, 50)], "proba": scores_main}).to_csv(
                f"pred_scores_main_{mn}.csv", index=False, encoding="utf-8-sig"
            )
            pd.DataFrame({"number": [f"{i:02d}" for i in range(1, 50)], "proba": scores_sp}).to_csv(
                f"pred_scores_sp_{mn}.csv", index=False, encoding="utf-8-sig"
            )

        set_status(f"狀態：預測中 {mn}({idx+1}/{len(model_names)})", add_steps=1)

    union_main = sorted(set(n for mn in model_names for n in all_model_predictions_main[mn]))
    gprint(f"\n所有模型【聯合集合】推薦主號（各模型TOP_{PRED_MAIN_TOP_N} union）：{format_nums_with_star(union_main, drag_hint_main)}")

    cnt_main = Counter([n for mn in model_names for n in all_model_predictions_main[mn]])
    top_freq_main = sorted(cnt_main.items(), key=lambda x: (-x[1], x[0]))[:15]
    gprint(f"主號【模型推薦次數Top15】：{', '.join([f'{a:02d}×{b}' for a, b in top_freq_main])}")

    overlap_min = 2
    overlap_nums = sorted([n for n, v in cnt_main.items() if v >= overlap_min])
    if overlap_nums:
        gprint(f"主號【至少 {overlap_min} 個模型都推薦】：{format_nums_with_star(overlap_nums, drag_hint_main)}")

    union_sp = sorted(set(int(all_model_predictions_sp[mn]) for mn in model_names))
    gprint(f"所有模型【聯合集合】推薦特別號（各模型1支 union）：{format_nums_with_star(union_sp, drag_hint_sp)}")

    def save_latest_predict_lotto(predict_issue, predict_dt, preds_main_dict, preds_sp_dict):
        filename = "latest_predict_lotto.csv"
        dt_str = predict_dt.strftime("%Y-%m-%d %H:%M")
        with open(filename, mode="w", newline="", encoding="utf-8-sig") as f:
            writer = csv.writer(f)
            writer.writerow(["預測期數", "預測日期", "模型", "預測主號", "預測特別號"])
            for model_name in model_names:
                main_numbers = preds_main_dict[model_name]
                sp_num = preds_sp_dict[model_name]
                main_str = ",".join([f"{n:02d}" for n in sorted(main_numbers)])
                writer.writerow([str(predict_issue), dt_str, model_name, main_str, f"{int(sp_num):02d}"])
        gprint(f"\n已儲存最新一期各模型預測號碼於 {filename}！（主號TOP_{PRED_MAIN_TOP_N}，特別號1支；對獎優先用期數）")

    save_latest_predict_lotto(predict_next_issue, next_draw_dt, all_model_predictions_main, all_model_predictions_sp)

    auto_alpha = get_auto_mistake_alpha("latest_predict_result_lotto.csv")
    penalty_counts = load_penalty_from_real_results_lotto("latest_predict_result_lotto.csv", max_ball=49)
    penalty = auto_alpha * penalty_counts
    gprint(f"錯題本自動懲罰係數 MISTAKE_ALPHA = {auto_alpha:.3f}（依真實對獎紀錄量自動調整）")

    sum_main = np.zeros(49, dtype=np.float32)
    for mn in model_names:
        sum_main += all_model_pred_main_scores[mn].astype(np.float32)

    combined_main_A = np.maximum(0.0, sum_main - penalty)
    pick_main_A = sorted(list(np.argsort(combined_main_A)[-PRED_MAIN_TOP_N:] + 1))
    gprint(f"\n主號【未加權+錯題本】綜合票選（TOP_{PRED_MAIN_TOP_N}）：{format_nums_with_star(pick_main_A, drag_hint_main)}")

    weights = {mn: max(1e-6, float(np.mean(model_hits_main[mn]))) for mn in model_names}
    sum_main_w = np.zeros(49, dtype=np.float32)
    for mn in model_names:
        sum_main_w += weights[mn] * all_model_pred_main_scores[mn].astype(np.float32)

    combined_main_B = np.maximum(0.0, sum_main_w - penalty)
    pick_main_B = sorted(list(np.argsort(combined_main_B)[-PRED_MAIN_TOP_N:] + 1))
    gprint(f"主號【表現加權+錯題本】綜合票選（TOP_{PRED_MAIN_TOP_N}）：{format_nums_with_star(pick_main_B, drag_hint_main)}")

    sum_sp = np.zeros(49, dtype=np.float32)
    for mn in model_names:
        sum_sp += all_model_pred_sp_scores[mn].astype(np.float32)

    pick_sp_A = int(np.argmax(sum_sp) + 1) if sum_sp.sum() > 0 else int(all_model_predictions_sp[model_names[0]])
    gprint(f"特別號【機率加總】綜合票選（1支）：{format_nums_with_star([pick_sp_A], drag_hint_sp)}")

    SUGGEST_TICKETS_N = 10
    MAIN_POOL_TOP = 22
    tickets = suggest_tickets_from_scores(
        combined_main_scores=combined_main_B,
        sp_scores_sum=sum_sp,
        num_tickets=SUGGEST_TICKETS_N,
        main_pool_top=MAIN_POOL_TOP,
        seed=GLOBAL_SEED,
    )

    gprint(f"\n==== 539 同款：隨機建議票（依『表現加權+錯題本』權重）{SUGGEST_TICKETS_N} 張 | 主號池Top{MAIN_POOL_TOP} ====")
    for i, (m6, sp1) in enumerate(tickets, start=1):
        gprint(f"{i:02d}. 主號 {format_nums_with_star(m6, drag_hint_main)} | 特別號 {format_nums_with_star([sp1], drag_hint_sp)}")

    gprint("\n（提醒）對獎以『期數』為準；開獎時間為「規則+公告」推估。")

    summary_lines = []
    summary_lines.append("==== 大樂透 GUI：最新結果摘要 ====")
    summary_lines.append(f"回測範圍(被預測開獎日)：{backtest_eval_start_date} ~ {backtest_eval_end_date}")
    summary_lines.append(f"回測期數：{BACKTEST_N} | 回測主號TOP_N：{BACKTEST_MAIN_TOP_N} | 預測主號TOP_N：{PRED_MAIN_TOP_N} | K={K_INTERVAL}")
    summary_lines.append("")
    summary_lines.append("---- 各模型盈虧排名（不含特別號）----")
    for i, (mn, prof) in enumerate(ranked, start=1):
        summary_lines.append(f"{i}. {mn:<12} ➤ {prof} 元")
    summary_lines.append("")
    summary_lines.append(f"---- 下一期預測：期數 {predict_next_issue} / 開獎時間(推估) {next_draw_dt.strftime('%Y-%m-%d %H:%M')} ----")
    for mn in model_names:
        summary_lines.append(f"{mn:<12} 主號 {format_nums(all_model_predictions_main[mn])} | 特別號 {int(all_model_predictions_sp[mn]):02d}")
    summary_lines.append("")
    summary_lines.append(f"主號 union：{format_nums(union_main)}")
    summary_lines.append(f"特別號 union：{format_nums(union_sp)}")
    summary_lines.append("")
    summary_lines.append(f"主號【未加權+錯題本】綜合：{format_nums(pick_main_A)}")
    summary_lines.append(f"主號【表現加權+錯題本】綜合：{format_nums(pick_main_B)}")
    summary_lines.append(f"特別號【機率加總】綜合：{pick_sp_A:02d}")
    summary_lines.append("")
    summary_lines.append("---- 隨機建議票 ----")
    for i, (m6, sp1) in enumerate(tickets, start=1):
        summary_lines.append(f"{i:02d}. 主號 {format_nums(m6)} | 特別號 {sp1:02d}")
    summary_text = "\n".join(summary_lines) + "\n"

    set_status("狀態：完成", add_steps=(TOTAL_STEPS - done_steps))
    return {
        "summary_text": summary_text,
        "backtest_log_file": backtest_log_file,
        "history_file": history_fname,
    }


# ==============================
# GUI：主視窗（介面比照 539）
# ==============================
class Lotto649GUI:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("台灣大樂透 自動化預測系統（多模型 + 特徵工程 + Walk-forward 回測）")
        self.root.geometry("980x620")

        # 539 同款：進度條樣式（灰底 + 綠條）
        self.style = ttk.Style(self.root)
        try:
            self.style.theme_use("clam")
        except Exception:
            pass

        self.style.configure(
            "Party.Horizontal.TProgressbar",
            troughcolor="#e6e6e6",
            background="#00c853",
            bordercolor="#cfcfcf",
            lightcolor="#00c853",
            darkcolor="#00c853",
            thickness=14,
        )

        self.q = queue.Queue()
        self.worker = None
        self.stop_event = threading.Event()
        self.pause_event = threading.Event()

        self.latest_summary = ""
        self.latest_files = {}

        # 覆寫用：記錄每個模型那一行的起始 index
        self._model_line_start = {}

        self.result_win = None
        self.result_txt = None

        self._build_ui()
        self._pump_queue()

    # ------------------------------
    # Text 可寫入（disabled 仍可寫）：靠這兩個
    # ------------------------------
    def _make_text_readonly(self, widget):
        try:
            widget.configure(state="disabled")
        except Exception:
            pass

    def _text_write(self, widget, fn):
        try:
            widget.configure(state="normal")
        except Exception:
            pass
        try:
            fn()
        finally:
            try:
                widget.configure(state="disabled")
            except Exception:
                pass

    # ------------------------------
    # 539 同款：自動判斷顏色 tag
    # ------------------------------
    def _auto_tag(self, line: str) -> str:
        s = line.strip("\n")
        if not s.strip():
            return "normal"
        if "【錯誤】" in s or "Traceback" in s or "Error" in s:
            return "error"
        if s.startswith("✅") or "完成" in s or "已輸出" in s or "已儲存" in s:
            return "ok"
        if s.startswith("====") or s.startswith("----") or set(s.strip()) in ({'='}, {'-'}, {'_'}, {'*'}):
            return "sep"
        if s.startswith(">>>") or "[PRED]" in s:
            return "info"
        if "狀態：" in s:
            return "info"
        if "回測WF" in s or "Walk-forward" in s:
            return "warn"
        return "normal"

    def _build_ui(self):
        # ------------------------------
        # 上方控制列（排版比照 539）
        # ------------------------------
        top = ttk.Frame(self.root, padding=(8, 8, 8, 2))
        top.pack(fill="x")

        ttk.Label(top, text="回測最近期數（建議200期）：").grid(row=0, column=0, sticky="w")
        self.var_backtest_n = tk.IntVar(value=200)
        ttk.Spinbox(top, from_=50, to=3000, increment=10, width=8, textvariable=self.var_backtest_n).grid(
            row=0, column=1, sticky="w", padx=(4, 16)
        )

        ttk.Label(top, text="回測：").grid(row=0, column=2, sticky="w")
        self.var_bt_main_top_n = tk.IntVar(value=6)
        ttk.Spinbox(top, from_=1, to=49, increment=1, width=5, textvariable=self.var_bt_main_top_n).grid(
            row=0, column=3, sticky="w", padx=(4, 16)
        )

        ttk.Label(top, text="預測：").grid(row=0, column=4, sticky="w")
        self.var_pred_main_top_n = tk.IntVar(value=6)
        ttk.Spinbox(top, from_=1, to=49, increment=1, width=5, textvariable=self.var_pred_main_top_n).grid(
            row=0, column=5, sticky="w", padx=(4, 16)
        )

        # row1：按鈕列（比照 539）
        self.btn_run = ttk.Button(top, text="執行", command=self.on_run)
        self.btn_pause = ttk.Button(top, text="暫停", command=self.on_pause, state="disabled")
        self.btn_stop = ttk.Button(top, text="停止", command=self.on_stop, state="disabled")
        self.btn_result = ttk.Button(top, text="查看最新結果", command=self.open_result_window)

        self.btn_run.grid(row=1, column=0, sticky="w", pady=(6, 0))
        self.btn_pause.grid(row=1, column=1, sticky="w", pady=(6, 0))
        self.btn_stop.grid(row=1, column=2, sticky="w", pady=(6, 0))
        self.btn_result.grid(row=1, column=3, sticky="w", padx=(10, 0), pady=(6, 0))

        # ------------------------------
        # 狀態列（像 539：左狀態，右 progress + %）
        # ------------------------------
        stat = ttk.Frame(self.root, padding=(8, 0, 8, 6))
        stat.pack(fill="x")

        self.var_status = tk.StringVar(value="狀態：待命")
        self.lbl_status = ttk.Label(stat, textvariable=self.var_status)
        self.lbl_status.pack(side="left", fill="x", expand=True)

        self.var_percent = tk.StringVar(value="0%")
        self.lbl_percent = ttk.Label(stat, textvariable=self.var_percent, width=5, anchor="e")
        self.lbl_percent.pack(side="right", padx=(8, 0))

        self.pb = ttk.Progressbar(
            stat,
            length=240,
            mode="determinate",
            style="Party.Horizontal.TProgressbar",
            maximum=100,
        )
        self.pb.pack(side="right", padx=(0, 8))

        # ------------------------------
        # 黑底輸出區（539 同款）
        # ------------------------------
        out_frame = ttk.Frame(self.root, padding=8)
        out_frame.pack(fill="both", expand=True)

        self.txt = scrolledtext.ScrolledText(
            out_frame,
            wrap="word",
            font=("Consolas", 10),
            bg="#0b0f14",
            fg="#e0e0e0",
            insertbackground="#5bbcff",
        )
        # disabled 時顏色會走 disabledforeground → 補上
        try:
            self.txt.configure(disabledforeground="#e0e0e0")
        except Exception:
            pass

        self.txt.pack(fill="both", expand=True)
        self._make_text_readonly(self.txt)

        # 顏色 tag（跟你 539 一樣的色系）
        self.txt.tag_configure("normal", foreground="#e0e0e0")
        self.txt.tag_configure("info",   foreground="#5bbcff")
        self.txt.tag_configure("ok",     foreground="#00e676")
        self.txt.tag_configure("warn",   foreground="#ffd54f")
        self.txt.tag_configure("error",  foreground="#ff5252")
        self.txt.tag_configure("sep",    foreground="#9e9e9e")

        self._text_write(self.txt, lambda: self.txt.insert("end", "（GUI 已就緒）按「執行」開始回測+預測。\n", "info"))
        self.txt.see("end")

    # ------------------------------
    # queue / log
    # ------------------------------
    def log(self, item):
        self.q.put(item)

    def _append_text(self, s: str):
        tag = self._auto_tag(s)
        def _do():
            self.txt.insert("end", s, tag)
            self.txt.see("end")
        self._text_write(self.txt, _do)

    def _overwrite_model_line(self, model: str, line: str):
        def _do():
            if model not in self._model_line_start:
                start_index = self.txt.index("end-1c")
                self._model_line_start[model] = start_index
                self.txt.insert("end", line.rstrip("\n") + "\n", "warn")
                self.txt.see("end")
                return

            start_index = self._model_line_start[model]
            line_end = self.txt.index(f"{start_index} lineend")
            self.txt.delete(start_index, f"{line_end}+1c")
            self.txt.insert(start_index, line.rstrip("\n") + "\n", "warn")
            self.txt.see("end")

        self._text_write(self.txt, _do)

    def _pump_queue(self):
        try:
            while True:
                item = self.q.get_nowait()
                if isinstance(item, tuple) and len(item) >= 3 and item[0] == "overwrite":
                    _, model, line = item
                    self._overwrite_model_line(model, line)
                else:
                    self._append_text(str(item))
        except queue.Empty:
            pass

        self.root.after(60, self._pump_queue)

    # ------------------------------
    # progress
    # ------------------------------
    def set_progress(self, status_text, prog01=None):
        def _u():
            if status_text is not None:
                self.var_status.set(status_text)
            if prog01 is not None:
                p = float(max(0.0, min(1.0, prog01)))
                self.pb["value"] = p * 100
                self.var_percent.set(f"{int(p*100)}%")
        self.root.after(0, _u)

    # ------------------------------
    # buttons
    # ------------------------------
    def on_run(self):
        if self.worker and self.worker.is_alive():
            messagebox.showinfo("提示", "目前正在執行中")
            return

        self.stop_event.clear()
        self.pause_event.clear()
        self._model_line_start = {}

        BACKTEST_N = int(self.var_backtest_n.get())
        BACKTEST_MAIN_TOP_N = int(self.var_bt_main_top_n.get())
        PRED_MAIN_TOP_N = int(self.var_pred_main_top_n.get())

        K_INTERVAL = int(K_INTERVAL_DEFAULT)
        SHOW_N = int(SHOW_N_DEFAULT)

        self.btn_run.config(state="disabled")
        self.btn_pause.config(state="normal", text="暫停")
        self.btn_stop.config(state="normal")
        self.set_progress("狀態：啟動中...", 0.0)

        self.log("\n" + "=" * 110 + "\n")
        self.log(f"啟動參數：回測={BACKTEST_N}期 | 回測TOP={BACKTEST_MAIN_TOP_N} | 預測TOP={PRED_MAIN_TOP_N} | K={K_INTERVAL} | 顯示最近={SHOW_N}期\n")

        def q_print(s):
            self.log(s)

        def q_overwrite(model, line):
            self.log(("overwrite", model, line))

        def on_progress(status, prog01):
            self.set_progress(status, prog01)

        def worker_fn():
            try:
                res = run_pipeline(
                    BACKTEST_N=BACKTEST_N,
                    BACKTEST_MAIN_TOP_N=BACKTEST_MAIN_TOP_N,
                    PRED_MAIN_TOP_N=PRED_MAIN_TOP_N,
                    K_INTERVAL=K_INTERVAL,
                    SHOW_N=SHOW_N,
                    q_print=q_print,
                    q_overwrite=q_overwrite,
                    on_progress=on_progress,
                    stop_event=self.stop_event,
                    pause_event=self.pause_event,
                )
                self.latest_summary = res.get("summary_text", "")
                self.latest_files = res
                self.root.after(0, self.open_result_window)
            except KeyboardInterrupt:
                self.log("\n【已停止】使用者中止執行。\n")
                self.set_progress("狀態：已停止", 0.0)
            except Exception as e:
                self.log(f"\n【錯誤】{type(e).__name__}: {e}\n")
                self.set_progress("狀態：錯誤", 0.0)
            finally:
                self.root.after(0, self._finish_ui_state)

        self.worker = threading.Thread(target=worker_fn, daemon=True)
        self.worker.start()

    def on_pause(self):
        if not (self.worker and self.worker.is_alive()):
            return
        if not self.pause_event.is_set():
            self.pause_event.set()
            self.btn_pause.config(text="繼續")
            self.set_progress("狀態：暫停中...", None)
            self.log("\n【暫停】\n")
        else:
            self.pause_event.clear()
            self.btn_pause.config(text="暫停")
            self.log("\n【繼續】\n")

    def on_stop(self):
        if not (self.worker and self.worker.is_alive()):
            return
        if messagebox.askyesno("確認", "確定要停止嗎？"):
            self.stop_event.set()
            self.pause_event.clear()
            self.log("\n【停止請求】等待安全中止...\n")

    def _finish_ui_state(self):
        self.btn_run.config(state="normal")
        self.btn_pause.config(state="disabled", text="暫停")
        self.btn_stop.config(state="disabled")

    # ------------------------------
    # result window（黑底摘要視窗，跟 539 一樣）
    # ------------------------------
    def open_result_window(self):
        if self.result_win is not None and self.result_win.winfo_exists():
            self.result_win.lift()
            return

        w = tk.Toplevel(self.root)
        w.title("最新結果（回測/預測摘要）")
        w.geometry("980x720")

        top = ttk.Frame(w, padding=8)
        top.pack(fill="x")

        def clear_result():
            if self.result_txt is not None:
                self._text_write(self.result_txt, lambda: self.result_txt.delete("1.0", "end"))

        def save_result_to_file():
            try:
                if self.result_txt is None:
                    return
                self.result_txt.configure(state="normal")
                content = self.result_txt.get("1.0", "end").strip("\n")
                self.result_txt.configure(state="disabled")
                if not content.strip():
                    messagebox.showinfo("提示", "目前沒有內容可存檔")
                    return
                fn = f"GUI_latest_result_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
                with open(fn, "w", encoding="utf-8-sig") as f:
                    f.write(content + "\n")
                messagebox.showinfo("完成", f"已存檔：{fn}")
            except Exception as e:
                messagebox.showerror("錯誤", f"存檔失敗：{e}")

        ttk.Button(top, text="清空", command=clear_result).pack(side="left")
        ttk.Button(top, text="存成txt", command=save_result_to_file).pack(side="left", padx=6)

        file_info = []
        if self.latest_files:
            if self.latest_files.get("backtest_log_file"):
                file_info.append(f"回測完整紀錄：{self.latest_files['backtest_log_file']}")
            if self.latest_files.get("history_file"):
                file_info.append(f"回測統計pkl：{self.latest_files['history_file']}")
        ttk.Label(top, text=(" | ".join(file_info) if file_info else "")).pack(side="left", padx=10)

        out = scrolledtext.ScrolledText(
            w,
            wrap="word",
            font=("Consolas", 10),
            bg="#0b0f14",
            fg="#e0e0e0",
            insertbackground="#5bbcff",
        )
        try:
            out.configure(disabledforeground="#e0e0e0")
        except Exception:
            pass

        out.pack(fill="both", expand=True, padx=8, pady=(0, 8))
        self._make_text_readonly(out)

        self.result_win = w
        self.result_txt = out

        def _fill():
            out.delete("1.0", "end")
            out.insert("end", self.latest_summary or "（尚無結果，請先執行）\n")
            out.see("end")
        self._text_write(out, _fill)

        def on_close():
            self.result_win = None
            self.result_txt = None
            w.destroy()

        w.protocol("WM_DELETE_WINDOW", on_close)

    def run(self):
        self.root.mainloop()


if __name__ == "__main__":
    app = Lotto649GUI()
    app.run()
